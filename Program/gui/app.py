"""Streamlit GUI for MFVRPTW final results.

The application presents pre-computed routing outcomes generated by the
MFVRPTW pipeline (Sweep → NN → ACS → RVND). No optimisation is performed here;
all data is consumed from existing artifacts.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List

import pandas as pd
import plotly.graph_objects as go
import streamlit as st

BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "data" / "processed"
DOCS_DIR = BASE_DIR / "docs"

FINAL_SOLUTION_PATH = DATA_DIR / "final_solution.json"
FINAL_SUMMARY_PATH = DOCS_DIR / "final_summary.md"
PARSED_INSTANCE_PATH = DATA_DIR / "parsed_instance.json"


def load_json(path: Path) -> Dict:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def read_markdown(path: Path) -> str:
    with path.open("r", encoding="utf-8") as handle:
        return handle.read()


def parse_markdown_table(markdown_text: str, header: str) -> pd.DataFrame:
    """Extract table that immediately follows the given markdown header."""
    lines = markdown_text.splitlines()
    table_lines: List[str] = []
    capture = False
    for line in lines:
        if line.strip().startswith("##") and header.lower() in line.strip().lower():
            capture = True
            continue
        if capture:
            if not line.strip():
                break
            table_lines.append(line)
    if not table_lines:
        return pd.DataFrame()

    # First line contains header row, second contains separator
    header_row = [cell.strip() for cell in table_lines[0].split("|") if cell.strip()]
    data_rows = []
    for row in table_lines[2:]:
        cells = [cell.strip() for cell in row.split("|") if cell.strip()]
        if cells:
            data_rows.append(cells)
    return pd.DataFrame(data_rows, columns=header_row)


def prepare_route_table(final_solution: Dict, instance_data: Dict) -> pd.DataFrame:
    fleet_lookup = {fleet["id"]: fleet for fleet in instance_data["fleet"]}
    rows = []
    for route in final_solution["routes"]:
        vehicle = fleet_lookup[route["vehicle_type"]]
        fixed_cost = vehicle["fixed_cost"]
        variable_cost = vehicle["variable_cost_per_km"] * route["total_distance"]
        rows.append(
            {
                "Cluster": route["cluster_id"],
                "Vehicle": route["vehicle_type"],
                "Route": " → ".join(map(str, route["sequence"])),
                "Distance (km)": round(route["total_distance"], 3),
                "Time (min)": round(route["total_time_component"], 3),
                "TW Violation (min)": round(route["total_tw_violation"], 3),
                "Objective": round(route["objective"], 3),
                "Cost (Rp)": round(fixed_cost + variable_cost, 2),
            }
        )
    return pd.DataFrame(rows)


def build_route_plot(final_solution: Dict, instance_data: Dict) -> go.Figure:
    nodes = {instance_data["depot"]["id"]: instance_data["depot"]}
    nodes.update({cust["id"]: cust for cust in instance_data["customers"]})

    depot_id = instance_data["depot"]["id"]

    fig = go.Figure()

    colour_palette = [
        "#1f77b4",
        "#ff7f0e",
        "#2ca02c",
        "#d62728",
        "#9467bd",
        "#8c564b",
        "#e377c2",
        "#7f7f7f",
        "#bcbd22",
        "#17becf",
    ]

    for index, route in enumerate(final_solution["routes"]):
        colour = colour_palette[index % len(colour_palette)]
        seq = route["sequence"]
        x_values = [nodes[node_id]["x"] for node_id in seq]
        y_values = [nodes[node_id]["y"] for node_id in seq]

        hover_text = []
        for node_id in seq:
            node = nodes[node_id]
            if node_id == depot_id:
                demand = "-"
                tw_start = instance_data["depot"]["time_window"]["start"]
                tw_end = instance_data["depot"]["time_window"]["end"]
            else:
                demand = node["demand"]
                tw_start = node["time_window"]["start"]
                tw_end = node["time_window"]["end"]
            hover_text.append(
                f"Node {node_id}<br>Demand: {demand}<br>TW: {tw_start} – {tw_end}"
            )

        fig.add_trace(
            go.Scatter(
                x=x_values,
                y=y_values,
                mode="lines+markers",
                name=f"Cluster {route['cluster_id']} ({route['vehicle_type']})",
                line=dict(color=colour, width=3),
                marker=dict(size=10),
                hoverinfo="text",
                text=hover_text,
            )
        )

    depot = nodes[depot_id]
    fig.add_trace(
        go.Scatter(
            x=[depot["x"]],
            y=[depot["y"]],
            mode="markers",
            name="Depot",
            marker=dict(size=14, color="#000000", symbol="diamond"),
            hoverinfo="text",
            text=["Depot"],
        )
    )

    fig.update_layout(
        title="Route Layout",
        xaxis_title="X Coordinate",
        yaxis_title="Y Coordinate",
        legend=dict(title="Clusters"),
        template="plotly_white",
        height=650,
    )
    return fig


def render_kpis(summary: Dict) -> None:
    st.markdown("## Key Performance Indicators")
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Total Distance (km)", f"{summary['total_distance']:.3f}")
    col2.metric("Total Cost (Rp)", f"{summary['total_cost']:,.0f}")
    col3.metric("TW Violations (min)", f"{summary['total_tw_violation']:.3f}")
    fleet_usage = ", ".join(
        f"{ftype}: {summary['fleet_usage'][ftype]}"
        for ftype in sorted(summary["fleet_usage"].keys())
    )
    col4.metric("Fleet Usage", fleet_usage)


def render_cluster_details(route_table: pd.DataFrame) -> None:
    st.markdown("## Cluster Detail")
    for _, row in route_table.sort_values("Cluster").iterrows():
        with st.expander(f"Cluster {row['Cluster']} – Vehicle {row['Vehicle']}"):
            st.write(
                {
                    "Route": row["Route"],
                    "Distance (km)": row["Distance (km)"],
                    "Time (min)": row["Time (min)"],
                    "TW Violation (min)": row["TW Violation (min)"],
                    "Objective": row["Objective"],
                    "Cost (Rp)": row["Cost (Rp)"]
                }
            )


def render_comparison_table(final_summary_md: str) -> None:
    comparison_df = parse_markdown_table(final_summary_md, "ACS vs.")
    if comparison_df.empty:
        st.warning("ACS vs. RVND comparison table not found in summary.")
        return
    st.markdown("## ACS vs. RVND Comparison")
    comparison_df = comparison_df.replace({"**": ""}, regex=False)
    if "Cluster" in comparison_df.columns:
        comparison_df["Cluster"] = comparison_df["Cluster"].str.replace("**", "", regex=False)
    numeric_columns = [col for col in comparison_df.columns if col not in {"Cluster"}]
    for column in numeric_columns:
        comparison_df[column] = (
            comparison_df[column]
            .str.replace(",", "")
            .str.replace("**", "", regex=False)
            .astype(float)
        )
    st.dataframe(
        comparison_df.style.format({col: "{:.3f}" for col in numeric_columns})
    )


def render_export_section(final_solution: Dict, route_table: pd.DataFrame, final_summary_md: str) -> None:
    st.markdown("## Export")
    col1, col2 = st.columns(2)
    with col1:
        st.download_button(
            "Download final_solution.json",
            data=json.dumps(final_solution, indent=2).encode("utf-8"),
            file_name="final_solution.json",
            mime="application/json",
        )
    with col2:
        csv_data = route_table.to_csv(index=False).encode("utf-8")
        st.download_button(
            "Download per-cluster summary (CSV)",
            data=csv_data,
            file_name="cluster_summary.csv",
            mime="text/csv",
        )
    st.download_button(
        "Download Markdown summary",
        data=final_summary_md.encode("utf-8"),
        file_name="final_summary.md",
        mime="text/markdown",
    )


def main() -> None:
    st.set_page_config(page_title="MFVRPTW Route Optimisation", layout="wide")

    st.title("MFVRPTW Route Optimization")
    st.caption("Sweep → NN → ACS → RVND")

    if not FINAL_SOLUTION_PATH.exists() or not FINAL_SUMMARY_PATH.exists():
        st.error("Required artifacts not found. Please ensure preprocessing has been completed.")
        return

    final_solution = load_json(FINAL_SOLUTION_PATH)
    final_summary_md = read_markdown(FINAL_SUMMARY_PATH)

    if not PARSED_INSTANCE_PATH.exists():
        st.error("Instance metadata missing (parsed_instance.json required for visualisation).")
        return
    instance_data = load_json(PARSED_INSTANCE_PATH)

    render_kpis(final_solution["summary"])

    st.markdown("## Route Visualisation")
    route_fig = build_route_plot(final_solution, instance_data)
    st.plotly_chart(route_fig, width="stretch")

    route_table = prepare_route_table(final_solution, instance_data)
    render_cluster_details(route_table)

    render_comparison_table(final_summary_md)

    render_export_section(final_solution, route_table, final_summary_md)

    st.sidebar.header("About")
    st.sidebar.info(
        "This dashboard presents pre-computed MFVRPTW results using the "
        "document-specified pipeline. No optimisation is performed in the UI."
    )


if __name__ == "__main__":
    main()
